# SLAM

## SLAM概述

SLAM实际是自主导航领域 定位与建图的交叉部分，即同步定位与建图

就定位来说

比如我从第0帧，我看到了三个特征点，然后我移动了。我在第一帧，我同样看到那三个特征点了，但是有一个位置变化。通过状态转移矩阵，我可以得到P<sub>0</sub>=T<sub>1</sub>T<sub>2</sub>T<sub>3</sub>……T<sub>n</sub>P<sub>n</sub>

当然，实际并不会这么精准

slam难也难在这实际从最底层从激光雷达的量测就不是一个准确的值，存在误差。所有这其实是一个概率的问题

从建图来说

你关注什么东西就建什么图

















课堂部分摘要

在SLAM（同步定位与建图）中，我们通常采用*贝叶斯递归估计*的方法，包括*扩展卡尔曼滤波（EKF）*和*粒子滤波*等方法。EKF是其中的一种核心方法，同时我们也可以使用粒子滤波进行状态估计。

### 1. 递归估计与马尔科夫假设

在SLAM的过程中，我们通常**假设系统的状态仅依赖于当前时刻和上一时刻的信息**，而不依赖于更早的历史数据，这就是**马尔科夫假设**。然而，这种假设在实际应用中并不总是合理。例如，在机器人移动过程中，由于测量误差的存在，位置估计往往不会完全重合。如果不考虑历史测量信息，就可能**导致累积误差**的增加。因此，我们需要**通过优化方法来融合多个时刻的测量数据**，以获得更精确的地图。

### 2. 地图匹配与优化方法

在构建SLAM地图时，我们通常会遇到**地图对齐**的问题。例如，在不同时间段获取的点云数据可能存在误差，而相同的墙角或地标应该在地图中保持一致。为了实现这一点，我们可以使用**优化方法来最小化测量误差**。

这实际上是点云配准的问题：

#### 点云配准

**点云配准（Point Cloud Registration）**指的是**输入两幅点云 Ps (source) 和 Pt (target)** ，**输出一个变换 T使得 T(Ps)和 Pt 的重合程度尽可能高**。变换 T可以是刚性的(rigid)，只包括旋转平移，也可以不是。（非刚性变换（non-rigid transformation）则允许形状或大小发生改变，例如扭曲、拉伸、缩放等。）

**点云配准**可以分为**粗配准**（Coarse Registration）和**精配准**（Fine Registration）两步。粗配准指的是**在两幅点云之间的变换完全未知的情况下进行较为粗糙的配准**，目的主要是**为精配准提供较好的变换初值**；精配准则是**给定一个初始变换，进一步优化**得到更精确的变换。

其中，常见的方法是基于ICP（迭代最近点），NDT（正态分布变换）的地图匹配方法。

- **ICP（Iterative Closest Point）**：假设环境是连续的，并通过点云匹配的方法进行优化。
- **NDT（Normal Distribution Transform）**：将**环境划分成网格**，并在**每个网格内建立正态分布模型**，以此进行匹配。

两种方法各有优劣，ICP适用于**高精度的点云匹配**，而NDT在**处理大规模数据**时更稳定。

#### ICP   

##### 直观理解：

$$
R^*, t^* = \arg\min_{R,t} \frac{1}{|P_s|} \sum_{i=1}^{|P_s|} ||p_i^t - (R \cdot p_i^s + t)||^2
$$

**找到最近点**：假设已有一个大致的变换参数 R和 t，在源点云（Ps）和目标点云（Pt）之间，通过寻找每个源点到目标点云中最近的点，确定两点云的对应关系。（在实际SLAM中，这个大致的变换是里程计给的）

**求解最优变换**：在确定点对的基础上，利用最小二乘法计算使得两点云尽可能对齐的旋转矩阵 R 和平移向量 t。

**迭代更新**：将求得的变换参数应用于源点云，并重复上述两个步骤，直到某个收敛条件（例如变换参数变化量、损失变化量小于阈值，或者达到最大迭代次数）。

##### ICP算法的一般流程：

1. 点云预处理

   - 滤波、清理数据等 采样（均匀采样、随机采样、法向量采样**如均匀采样，我怎么知道两帧采的一样**）

2. 匹配

   - 应用上一步求解出的变换，找最近点

3. 加权

   - 调整一些对应点对的权重

4. 剔除不合理的对应点对

5. 计算 loss

6. 最小化 loss，求解当前最优变换

7. 回到步骤 2. 进行迭代，直到收敛

   故：实际就只有**两个子问题**：

   - **找最近点**
   - **找最优变换**

   ##### 找最近点

   利用初始 R0、t0或上一次迭代得到的 Rk−1、tk−1对初始点云进行变换，得到一个临时的变换点云，然后用这个点云和目标点云进行比较，找出源点云中每一个点在目标点云中的最近邻点。

   如果直接进行比较找最近邻点（**暴力搜索**），需要进行两重循环，计算复杂度为 O(|Ps|⋅|Pt|)，这一步会比较耗时，常见的加速方法有：

   - 设置距离阈值，当点与点距离小于一定阈值就认为找到了对应点，不用遍历完整个点集；
   - 使用 ANN(Approximate Nearest Neighbor) 加速查找，常用的有 KD-tree；KD-tree 建树的计算复杂度为 `O(N log(N))`，查找通常复杂度为 `O(log(N))`（最坏情况下 `O(N)`）。

   ##### 找最优变换

#### NDT

应用于三维点的统计模型，使用**标准最优化技术**来确定两个点云间的最优的匹配，因为其在配准过程中不利用对应点的特征计算和匹配，所以时间比其他方法快。

与占用网格相似，我们将2D平面细分为细胞。 对于每个单元，我们分配一个正态分布，用于测量每个点通过变换后在对应的cell里的概率。变换的结果是一个分段连续且可微的概率密度函数，可以通过牛顿算法用于匹配另一幅扫描数据。因此，无需显式建立点对点对应关系。

**进行匹配的过程被定义为最大化对齐点在该密度上的得分总和。**

##### 过程：

先将参考点云划分成一个一个cell，在每个cell里需要做以下几件事

1、收集所有在这个框中2d的点

2、求均值和协方差

求得在这个框内的正态分布，取P(x)作为样本点的概率函数
$$
p(x) \sim \exp\left(-\frac{(x - q)^T \Sigma^{-1} (x - q)}{2}\right)
$$

###### 说明两个实现细节

**1. 处理离散化效应**
 为了最小化离散化带来的影响，我们采用了四个相互重叠的网格：

- 首先放置一个边长为 lll 的网格；
- 然后水平偏移 l/2l/2l/2 放置第二个网格；
- 再垂直偏移 l/2l/2l/2 放置第三个网格；
- 最后同时水平和垂直偏移 l/2l/2l/2 放置第四个网格。

这样，每个 2D 点都会落入四个单元格中。在下面的部分，我们不会显式考虑这一点，而是将算法描述为每个点仅对应一个单元格。*在计算点的概率密度时，会隐式地对四个单元格的密度进行评估，并将结果相加。*what？

**2. 处理协方差矩阵的退化问题**
 在一个**无噪声的测量环境下**，协方差矩阵可能会变得**奇异**，无法求逆。在实际应用中，协方差矩阵**有时会接近奇异**。为了避免这种情况，我们检查**协方差矩阵 Σ的较小特征值**是否**至少为较大特征值的 0.001 倍**。如果不是，就将其设定为该值。what？



由里程计给出了初始变换P，实现将源点云变换到参考点云
$$
\begin{pmatrix}
x' \\
y'
\end{pmatrix}
=
\begin{pmatrix}
\cos \phi & -\sin \phi \\
\sin \phi & \cos \phi
\end{pmatrix}
\begin{pmatrix}
x \\
y
\end{pmatrix}
+
\begin{pmatrix}
t_x \\
t_y
\end{pmatrix}
$$
如果在参数 p下，对所有点 Xi′及其对应的参数 Σi和 qi进行正态分布评估的**总和达到最大值**，那么该映射可以视为最优的。

我们将这个总和称为 **p的得分（score）**，其定义为：
$$
\text{score}(p) = \sum_i \exp\left(-\frac{(x'_i - q_i)^T \Sigma^{-1}_i (x'_i - q_i)}{2}\right)
$$
这就是要优化的目标，在下面用到牛顿算法优化

###### 牛顿算法优化

通常谈到优化都被描述为最小化问题，故只需要求解-score最小即可
$$
H \Delta p = -g
$$
这就是需要迭代求解的方程

来源于牛顿法基于泰勒展开近似描述函数的局部行为
$$
f(p + \Delta p) \approx f(p) + g^T \Delta p + \frac{1}{2} \Delta p^T H \Delta p
$$
对 Δp求导后就是优化函数

其中H和g分别是海森阵和雅可比，且下面的是矩阵中的一个元素
$$
\frac{\partial f}{\partial p_i}, \quad H_{ij} = \frac{\partial f}{\partial p_i \partial p_j}
$$
为了让score更简单
$$
q = x'_i - q_i
$$
且一个点的score令为s：
$$
s = - \exp \left( -\frac{q^T \Sigma^{-1} q}{2} \right)
$$

$$
g_i = - \frac{\partial s}{\partial p_i} = - \frac{\partial s}{\partial q} \frac{\partial q}{\partial p_i} = q^T \Sigma^{-1} \frac{\partial q}{\partial p_i} \exp \left( -\frac{q^T \Sigma^{-1} q}{2} \right)
$$

其中有
$$
J_T = \begin{pmatrix} 
1 & 0 & -x \sin \phi - y \cos \phi \\
0 & 1 & x \cos \phi - y \sin \phi 
\end{pmatrix}
$$

$$
H_{ij} = - \frac{\partial s}{\partial p_i \partial p_j} = - \exp \left( -\frac{q^T \Sigma^{-1} q}{2} \right) \left( \left( -q^T \Sigma^{-1} \frac{\partial q}{\partial p_i} \right) \left( -q^T \Sigma^{-1} \frac{\partial q}{\partial p_j} \right) + \left( -q^T \Sigma^{-1} \frac{\partial^2 q}{\partial p_i \partial p_j} \right) + \left( - \frac{\partial q^T}{\partial p_j} \Sigma^{-1} \frac{\partial q}{\partial p_i} \right) \right)
$$

其中有
$$
\frac{\partial^2 q}{\partial p_i \partial p_j} =
\begin{cases}
\begin{pmatrix}
-x \cos \phi + y \sin \phi \\
-x \sin \phi - y \cos \phi
\end{pmatrix} & \text{if } i = j = 3 \\
\begin{pmatrix}
0 \\
0
\end{pmatrix} & \text{otherwise}
\end{cases}
$$
**但是要记得，这边的雅可比和海森都只是对一个点的计算。回归到总的-score，那么如果我有100个点，我就需要求出100个gi，并加在一起，海森也是如此**

一次迭代后得到
$$
p \leftarrow p + \Delta p
$$


#### ICP与NDT之间的异同分析



### 3. SLAM的前端与后端

SLAM系统通常分为前端和后端两个部分。

- **前端（Front-end）**：负责数据的实时处理，例如特征提取、数据关联等，主要目标是提供初步的位姿估计。
- **后端（Back-end）**：通过优化方法（如图优化）来校正前端估计的误差，并最终构建出更精确的地图。

在目前的SLAM研究中，后端优化的计算量通常较大，因此前端需要提供足够精确的初步估计，以减少后端的计算负担。 

SLAM是一个庞大的研究领域，包括定位、建图、数据关联、优化等多个方面。建立清晰的知识体系，并结合实践进行学习，将有助于更深入地理解SLAM技术。